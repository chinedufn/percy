<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Percy - Isomorphic Web Apps in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="views/index.html"><strong aria-hidden="true">1.</strong> Rendering Views</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="html-macro/index.html"><strong aria-hidden="true">1.1.</strong> Writing html!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="html-macro/html-macro.html"><strong aria-hidden="true">1.1.1.</strong> Writing html!</a></li><li class="chapter-item expanded "><a href="html-macro/classes/index.html"><strong aria-hidden="true">1.1.2.</strong> Classes</a></li><li class="chapter-item expanded "><a href="html-macro/text/index.html"><strong aria-hidden="true">1.1.3.</strong> Working with Text</a></li><li class="chapter-item expanded "><a href="html-macro/custom-components/index.html"><strong aria-hidden="true">1.1.4.</strong> Custom Components</a></li><li class="chapter-item expanded "><a href="html-macro/setting-inner-html/index.html"><strong aria-hidden="true">1.1.5.</strong> Setting Inner HTML</a></li><li class="chapter-item expanded "><a href="html-macro/conditional-rendering/index.html"><strong aria-hidden="true">1.1.6.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="html-macro/real-elements-and-nodes/index.html"><strong aria-hidden="true">1.1.7.</strong> Real Elements and Nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="html-macro/real-elements-and-nodes/on-create-elem/index.html"><strong aria-hidden="true">1.1.7.1.</strong> On Create Element</a></li><li class="chapter-item expanded "><a href="html-macro/real-elements-and-nodes/on-remove-elem/index.html"><strong aria-hidden="true">1.1.7.2.</strong> On Remove Element</a></li></ol></li><li class="chapter-item expanded "><a href="html-macro/boolean-attributes/index.html"><strong aria-hidden="true">1.1.8.</strong> Boolean Attributes</a></li></ol></li><li class="chapter-item expanded "><a href="lists/index.html"><strong aria-hidden="true">1.2.</strong> Lists</a></li><li class="chapter-item expanded "><a href="virtual-dom/index.html"><strong aria-hidden="true">1.3.</strong> Virtual DOM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="virtual-dom/unit-testing-views.html"><strong aria-hidden="true">1.3.1.</strong> Unit Testing your Views</a></li></ol></li><li class="chapter-item expanded "><a href="views/server-side-rendering/index.html"><strong aria-hidden="true">1.4.</strong> Server Side Rendering (SSR)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="views/server-side-rendering/why-ssr.html"><strong aria-hidden="true">1.4.1.</strong> Why SSR</a></li><li class="chapter-item expanded "><a href="views/server-side-rendering/how-to-ssr.html"><strong aria-hidden="true">1.4.2.</strong> How to SSR</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="router/type-safe-url-param/index.html"><strong aria-hidden="true">2.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="router/type-safe-url-param/index.html"><strong aria-hidden="true">2.1.</strong> Type Safe URL Params</a></li><li class="chapter-item expanded "><a href="router/on-visit/index.html"><strong aria-hidden="true">2.2.</strong> On Visit Callback</a></li></ol></li><li class="chapter-item expanded "><a href="css-in-rust.html"><strong aria-hidden="true">3.</strong> CSS in Rust</a></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">4.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="contributing/ways-to-contribute.html"><strong aria-hidden="true">4.2.</strong> Types of Contributions</a></li><li class="chapter-item expanded "><a href="contributing/internal-design/index.html"><strong aria-hidden="true">4.3.</strong> Internal Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="diff-patch/index.html"><strong aria-hidden="true">4.3.1.</strong> Diff / Patch Algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="diff-patch/diff-patch-walkthrough/index.html"><strong aria-hidden="true">4.3.1.1.</strong> Diff / Patch Walkthrough</a></li><li class="chapter-item expanded "><a href="diff-patch/fixing-diff-patch-issues/index.html"><strong aria-hidden="true">4.3.1.2.</strong> Fixing diff/patch issues</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/internal-design/sibling-text-nodes.html"><strong aria-hidden="true">4.3.2.</strong> Handling text siblings</a></li><li class="chapter-item expanded "><a href="contributing/internal-design/event-handling/index.html"><strong aria-hidden="true">4.3.3.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="contributing/router/index.html"><strong aria-hidden="true">4.3.4.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/router/macro/index.html"><strong aria-hidden="true">4.3.4.1.</strong> route macro</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/html-macro/index.html"><strong aria-hidden="true">4.3.5.</strong> html macro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/html-macro/compile-time-errors.html"><strong aria-hidden="true">4.3.5.1.</strong> Compile Time Errors</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Percy - Isomorphic Web Apps in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>Note: The book is a work in progress. Some chapters are empty placeholders that will be filled in over time.</p>
</blockquote>
<p><code>Percy</code> a collection of libraries for building interactive frontend browser apps with Rust + WebAssembly.</p>
<p>Percy supports server side rendering out of the box.</p>
<p><code>Percy</code> is not yet ready for production (unless you're incredibly brave), but if you're
interested in using it for real things you can <a href="https://github.com/chinedufn/percy/watchers">watch the development progress.</a>.</p>
<h3 id="what-is-percy"><a class="header" href="#what-is-percy">What is Percy?</a></h3>
<p>Percy is a toolkit geared towards building single page web apps entirely in Rust that can also be rendered at the server.</p>
<p>This allows you to build search engine friendly browser applications in Rust.</p>
<h3 id="a-snippet"><a class="header" href="#a-snippet">A snippet</a></h3>
<pre><pre class="playground"><code class="language-rust">

use percy_dom::prelude::*;

// Percy supports events, classes, attributes a virtual dom
// with diff/patch and everything else that you'd expect from
// a frontend toolkit.
//
// This, however, is just the most basic example of rendering
// some HTML on the server side.
fn main () {
  let some_component = html! {
    &lt;div class=&quot;cool-component&quot;&gt;Hello World&lt;/div&gt;
  };

  let html_string = some_component.to_string();
  println!(&quot;{}&quot;, html_string);
}
</code></pre></pre>
<h3 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h3>
<p><code>Percy</code> is very young and going through the early stages of development. Our roadmap is
is mainly led by Real World Driven Development.</p>
<p>This means that we're using <code>Percy</code> to build a real, production web app and ironing out
the kinks and fixing the bugs as we go.</p>
<p>Once the tools have stabilized and we've settled into a clean structure for <code>Percy</code>
applications we'll publish a CLI for generating a production-grade starter project with
everything that you need to get up and running.</p>
<p>Check out the <a href="https://github.com/chinedufn/percy/issues">Percy issue tracker</a> and
maybe open a couple of your own!</p>
<h3 id="notable-features"><a class="header" href="#notable-features">Notable Features</a></h3>
<p><code>Percy</code> is still young, so the feature set is still growing and maturing. At the moment:</p>
<ul>
<li>
<p>An <code>html!</code> macro that generates a virtual dom that can can be rendered into a DOM element
on the frontend or a <code>String</code> on the backend.</p>
</li>
<li>
<p>CSS in Rust - Optionally writing your CSS styles right next to your <code>html!</code> components instead
of in separate CSS/Sass/etc files.</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rendering-views"><a class="header" href="#rendering-views">Rendering Views</a></h1>
<p>Almost all front-end web applications seek to display some (often times interactive)
content to a user.</p>
<p>This section will dive into how to render content with <code>Percy</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="html-macro"><a class="header" href="#html-macro">HTML Macro</a></h1>
<p>This chapter discusses rendering HTML using the <code>html!</code> macro</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="writing-html"><a class="header" href="#writing-html">Writing html!</a></h1>
<h3 id="static-text"><a class="header" href="#static-text">Static text</a></h3>
<p>Text that will never change can be typed right into your HTML</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use percy_dom::prelude::*;

html!{
  &lt;div&gt; Text goes here &lt;/div&gt;
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="text-variables"><a class="header" href="#text-variables">Text variables</a></h3>
<p>Text variables must be wrapped in braces.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use percy_dom::prelude::*;

let text_var = &quot; world&quot;;

html! {
  Hello { &lt;div&gt; { text_var } &lt;/div&gt; }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Attributes work just like regular HTML.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let view = html!{
  &lt;div id='my-id' class='big wide'&gt;&lt;/div&gt;
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>html! {
    &lt;button
      onclick=move|_event: web_sys::MouseEvent| {
        web_sys::console::log_1(&amp;&quot;clicked!&quot;.into());
      }
    &gt;
      Click me!
    &lt;/button&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="nested-components"><a class="header" href="#nested-components">Nested components</a></h3>
<p><code>html!</code> calls can be nested.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let view1 = html!{ &lt;em&gt; &lt;/em&gt; };
let view2 = html{ &lt;span&gt; &lt;/span&gt; }

let parent_view = html! {
  &lt;div&gt;
    { view1 }
    { view2 }
    {
      html! {
        Nested html! call
      }
    }
  &lt;/div&gt;
};


let html_string = parent_view.to_string();
// Here's what the String looks like:
// &lt;div&gt;&lt;em&gt;&lt;/em&gt;&lt;span&gt;&lt;/span&gt;Nested html! call&lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterable-children"><a class="header" href="#iterable-children">Iterable Children</a></h3>
<p>Any type that implements IntoIter<VirtualNode> can be used as a child element within a block.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = vec![&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]
    .map(|item_num| {
      html! { 
        &lt;li&gt;
          List item number { item_num }
        &lt;/li&gt;
      }
    });

html! {
  &lt;ul&gt; { list } &gt;/ul&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>You can use Rust comments within your HTML</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>html! {
  /* Main Div */
  &lt;div&gt;
    &lt;br /&gt;
    // Title
    &lt;h2&gt;Header&lt;/h2&gt;
    &lt;br /&gt;
  &lt;/div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<pre><code class="language-rust no_run ignore">let _node = html! {
    &lt;div class=&quot;some classes here&quot;&gt;
        &lt;span class=[&quot;array&quot;, &quot;works&quot;, &quot;too&quot;]&gt;&lt;/span&gt;

        &lt;strong class=vec![&quot;vec&quot;, &quot;works&quot;, &quot;as&quot;, &quot;well&quot;]&gt;&lt;/strong&gt;

        &lt;em class=vec![&quot;vec&quot;, &quot;works&quot;, &quot;as&quot;, &quot;well&quot;]&gt;&lt;/em&gt;

        &lt;label class=[&quot;as_ref&quot;, &quot;str&quot;, &quot;works&quot;, CssClass::BigButton]&gt;&lt;/label&gt;
    &lt;/div&gt;
};

enum CssClass {
    BigButton
}

impl AsRef&lt;str&gt; for CssClass {
	fn as_ref (&amp;self) -&gt; &amp;str {
		match self {
		    Self::BigButton =&gt; &quot;big-button&quot;
		}
	}
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="working-with-text"><a class="header" href="#working-with-text">Working with Text</a></h1>
<p>One of the most popular types of nodes in the DOM is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Text">Text</a> node, and the `html! macro
focuses heavily on making them as easy to create as possible.</p>
<p>You can just type unquoted text into the <code>html!</code> macro and neighboring text will get combined into a single <code>Text</code> node, much
like the way that web browsers handle text from html documents.</p>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let interpolated_text = &quot;interpolate text variables.&quot;;

    let example = html! {
       &lt;div&gt;
            Text can be typed directly into your HTML.
            &lt;div&gt;Or you can also {interpolated_text}&lt;/div&gt;
       &lt;/div&gt;
    };
}
</code></pre></pre>
<h2 id="preserving-space-between-blocks"><a class="header" href="#preserving-space-between-blocks">Preserving Space Between Blocks</a></h2>
<p>You should always get the same spacing (or lack there of) between text and other elements as you would
if you were working in a regular old <code>.html</code> file.</p>
<p>We'll preserve newline characters so that <code>white-space: pre-wrap</code> etc will work as expected.</p>
<p>When it comes to interpolated variables, we base spacing on the spacing outside of the braces, not the
inside.</p>
<p>Let's illustrate:</p>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let text = &quot;hello&quot;;

    html! { &lt;div&gt;{ hello }&lt;/div&gt; }; // &lt;div&gt;hello&lt;/div&gt;
    html! { &lt;div&gt;{hello}&lt;/div&gt; }; // &lt;div&gt;hello&lt;/div&gt;

    html! { &lt;div&gt; { hello } &lt;/div&gt; }; // &lt;div&gt; hello &lt;/div&gt;
    html! { &lt;div&gt; {hello} &lt;/div&gt; }; // &lt;div&gt; hello &lt;/div&gt;

    html! { &lt;div&gt;{hello} &lt;/div&gt; }; // &lt;div&gt;hello &lt;/div&gt;
    html! { &lt;div&gt;   {hello}&lt;/div&gt; }; // &lt;div&gt;   hello&lt;/div&gt;
}
</code></pre></pre>
<h2 id="preserving-white-space"><a class="header" href="#preserving-white-space">Preserving white-space</a></h2>
<p>Certain CSS styles such as <code>white-space: pre-wrap</code> will preserve all space and new lines within text.</p>
<p>The <code>html-macro</code> will treat all sequences of whitespace as a single whitespace, so in cases that you don't want that you'll need to
use a text variable for your text.</p>
<p>Fortunately this should be incredibly uncommon for almost all use cases.</p>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let text = r#&quot;This needs
it's whitespace perfectly
      preserved&quot;#;

    html! { &lt;span style=&quot;white-space: pre-wrap&quot;&gt;{ text }&lt;/span&gt; };
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="custom-components"><a class="header" href="#custom-components">Custom Components</a></h1>
<p>Percy's <code>html!</code> macro supports custom components.</p>
<p>You can create a component by implementing the <code>View</code> trait.</p>
<p>Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn page() -&gt; VirtualNode {
    html! {
        &lt;div&gt;
            &lt;ChildView count={0}/&gt;
        &lt;/div&gt;
    }
}

struct ChildView {
    count: u8,
}

impl View for ChildView {
    fn render(&amp;self) -&gt; VirtualNode {
        html! {
            &lt;div&gt;
                Count is {format!(&quot;{}&quot;, self.count)}
            &lt;/div&gt;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="setting-inner-html"><a class="header" href="#setting-inner-html">Setting Inner HTML</a></h1>
<p>You'll sometimes want to use a string of HTML in order to set the child nodes for an element.</p>
<p>For example, if you're creating a tool tip component you might want to be able to support setting tool tips using
arbitrary HTML such as <code>&quot;Hello &lt;strong&gt;World!&lt;/strong&gt;&quot;</code>:</p>
<p>You can use the <code>SpecialAttributes.dangerous_inner_html</code> attribute to set inner html.</p>
<p>Note that it is called <code>dangerous</code> because it can potentially expose your application to <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a> attacks if your application
trusts arbitrary un-escaped HTML strings.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let tooltip_contents = &quot;&lt;span&gt;hi&lt;/span&gt;&quot;;

let mut div: VirtualNode = html! {
&lt;div&gt;&lt;/div&gt;
};
div.as_velement_mut()
    .unwrap()
    .special_attributes
    .dangerous_inner_html = Some(tooltip_contents.to_string());

let div: Element = div.create_dom_node().node.unchecked_into();

assert_eq!(div.inner_html(), &quot;&lt;span&gt;hi&lt;/span&gt;&quot;);
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h1>
<p>Sometimes you'll want to conditionally render some html. You can use an <code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn conditional_render() {
    let maybe_render: Option&lt;VirtualNode&gt; = make_view();

    html! {
        &lt;div&gt;
            &lt;h1&gt;Hello World&lt;/h1&gt;
            { maybe_render }
        &lt;/div&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="real-elements-and-nodes"><a class="header" href="#real-elements-and-nodes">Real Elements and Nodes</a></h1>
<p>You'll sometimes want to do something to the real DOM [Node] that gets created from your <code>VirtualNode</code>.</p>
<p><code>percy-dom</code> exposes a number of ways to work with real DOM elements.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="on-create-element"><a class="header" href="#on-create-element">On Create Element</a></h1>
<p>The <code>on_create_elem</code> special attribute allows you to register a function that will be called
when the element is first created.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut div: VirtualNode = html! {
&lt;div&gt;
    &lt;span&gt;This span should get replaced&lt;/span&gt;
&lt;/div&gt;
};

div.as_velement_mut()
    .unwrap()
    .special_attributes
    .set_on_create_element(
        &quot;some-key&quot;,
        move |elem: web_sys::Element| {
            elem.set_inner_html(&quot;Hello world&quot;);
        },
    ));

let div: Element = div.create_dom_node().node.unchecked_into();

assert_eq!(div.inner_html(), &quot;Hello world&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="macro-shorthand"><a class="header" href="#macro-shorthand">Macro shorthand</a></h2>
<p>You can also use the <code>html!</code> macro to set the <code>on_create_element</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = html! {
  &lt;div
    key=&quot;some-key&quot;
	on_create_element = move |element: web_sys::Element| {
	    element.set_inner_html(&quot;After&quot;);
	}
  &gt;
    Before
  &lt;/div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="on-remove-element"><a class="header" href="#on-remove-element">On Remove Element</a></h1>
<p>The <code>on_remove_elem</code> special attribute allows you to register a function that will be called
when the element is removed from the DOM.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut div: VirtualNode = html! {
    &lt;div&gt;&lt;/div&gt;
};

div.as_velement_mut()
    .unwrap()
    .special_attributes
    .set_on_remove_element(
       &quot;some-key&quot;,
        move |_elem: web_sys::Element| {
          // ...
        },
    ));
<span class="boring">}
</span></code></pre></pre>
<h2 id="macro-shorthand-1"><a class="header" href="#macro-shorthand-1">Macro shorthand</a></h2>
<p>You can also use the <code>html!</code> macro to set the <code>on_remove_element</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = html! {
  &lt;div
    key=&quot;some-key&quot;
	on_remove_element = move |_element: web_sys::Element| {
	  // ...
	}
  &gt;
    Before
  &lt;/div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="boolean-attributes"><a class="header" href="#boolean-attributes">Boolean Attributes</a></h1>
<p>Boolean attributes such as <code>disabled</code> and <code>checked</code> can be added by assigning a bool as their value.</p>
<p>Both variables and expressions can be used.</p>
<p>Here are a few examples:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_disabled = true;
let video_duration = 500;

html! {
    &lt;video autoplay=false&gt;&lt;/video&gt;

    &lt;button disabled=is_disabled&gt;Disabled Button&lt;/disabled&gt;

    &lt;video controls={video_duration &gt; 100}&gt;&lt;/video&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<h2 id="keys"><a class="header" href="#keys">Keys</a></h2>
<p>When elements in a list are keyed the diffing and patching functions
will use the nodes' keys to know whether an element was removed or simply
moved.</p>
<p>This leads to fewer interactions with the real-DOM when modifying lists,
as well as being able to preserve child elements when keyed elements are moved
around in the list.</p>
<p>This preservation is useful when you have an element that has children
that aren't managed by percy-dom.</p>
<p>Using keys in lists is recommended, but not required.</p>
<p>Here's an example of using the key attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let items = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
let items: Vec&lt;VirtualNode&gt; = items
    .into_iter()
    .map(|key| {
        html! { &lt;div key={key}&gt;Div with key {key}&lt;/div&gt; }
    })
    .collect();

let node = html! {
  &lt;div&gt;
    { items }
  &lt;/div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="virtual-dom"><a class="header" href="#virtual-dom">Virtual DOM</a></h1>
<p>At the heart of the <code>Percy</code> toolkit is <code>percy-dom</code>, a crate that provides a virtual dom
implementation that allows you to write functional front-end applications.</p>
<p>This same <code>percy-dom</code> also works on the backend by rendering to a String instead of a DOM element.
This ability to render on the backend is commonly referred to as server side rendering.</p>
<pre><pre class="playground"><code class="language-rust">use percy_dom::prelude::*;

// The most basic example of rendering to a String
fn main () {
  let component = html! { &lt;div id=&quot;my-id&quot;&gt; Hello world &lt;/div&gt; };
  println!(&quot;{}&quot;, component);
  // &lt;div id=&quot;my-id&quot;&gt;Hello world&lt;/div&gt;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing-your-views"><a class="header" href="#unit-testing-your-views">Unit Testing your Views</a></h1>
<p>Percy's testing story is very much a work in progress, so please give feedback as you write tests!</p>
<p>Here's an example of unit testing your views. You can find it in the examples directory at <a href="https://github.com/chinedufn/percy/tree/master/examples/unit-testing-views">examples/unit-testing-views</a>.</p>
<pre><pre class="playground"><code class="language-rust">use percy_dom::prelude::*;

fn main() {
    println!(&quot;To see this example in action:&quot;);
    println!(&quot;cargo test -p unit-testing-components&quot;);
}

#[allow(unused)]
fn full_water_bottle() -&gt; VirtualNode {
    html! {
    &lt;div&gt;
        &lt;span id=&quot;full-water&quot;&gt;
          I am full of delicious and refreshing H20!
        &lt;/span&gt;
    &lt;/div&gt;
    }
}

#[allow(unused)]
fn not_full_water_bottle(percent_full: f32) -&gt; VirtualNode {
    let message = format!(
        &quot;Please fill me up :( I am only {} percent full :(&quot;,
        percent_full
    );
    let message = VirtualNode::text(&amp;*message);

    html! {
        &lt;div id=&quot;not-ful-water&quot;&gt;
         { message }
        &lt;/div&gt;
    }
}

#[allow(unused)]
fn water_bottle_view(percent_full: f32) -&gt; VirtualNode {
    if percent_full &gt; 0.5 {
        full_water_bottle()
    } else {
        not_full_water_bottle(percent_full)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn conditional_water_messaging() {
        assert_eq!(
            water_bottle_view(0.7)
                .children_recursive()
                .iter()
                .filter(|v| {
                    if let Some(elem) = v.as_velement_ref() {
                        return elem.attrs.get(&quot;id&quot;) == Some(&amp;&quot;full-water&quot;.into());
                    }

                    false
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .len(),
            1
        );

        let water_view = water_bottle_view(0.2587);

        assert_eq!(
            water_view
                .as_velement_ref()
                .expect(&quot;Not an element node&quot;)
                .children[0]
                .as_vtext_ref()
                .expect(&quot;Not a text node&quot;)
                .text,
            &quot; Please fill me up :( I am only 0.2587 percent full :( &quot;
        )
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server Side Rendering</a></h1>
<p>This section outlines Percy's server side rendering support.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="why-use-server-side-rendering"><a class="header" href="#why-use-server-side-rendering">Why use Server Side Rendering</a></h1>
<p>In recent years it has become popular for just about all of a web application to be rendered on the client.</p>
<p>Applications will often serve almost nothing but a <code>&lt;script&gt;</code> tag that loads up some front-end code (<code>JavaScript</code> and/or <code>WebAssembly</code>)
and that front-end code is responsible for rendering the application's <code>HTML</code> and interactions.</p>
<p>Here's an example of what many of today's web application boil down to:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;!-- application will render HTML here when it begins --&gt;
  &lt;/div&gt;
  &lt;!--
    One this applications loads it will
    inject some HTML into the body
  --&gt;
  &lt;script src=&quot;/my-application.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<hr />
<p>One downside to this approach is that a user must wait until the script begins rendering before seeing anything.</p>
<p>Let's illustrate:</p>
<pre><code>Client side rendering
without server side rendering:

┌─────────────────────────────────────┐
│   1) Client requests for web page   │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│2) Server responds with &lt;script&gt; tag │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│     3) Client downloads script      │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│4) Client parses the returned script │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 5) Client executes returned script  │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐  User first
│ 6) Script starts rendering content  │◀─   sees
└─────────────────────────────────────┘   content
</code></pre>
<p>Contrast this with server side rendering, where the initial page load might look something like this:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
  &lt;!--
    This content was sent down from the server so
    that the user sees something immediately!
  --&gt;
  &lt;/div&gt;

  &lt;script src=&quot;/my-application.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>And the flow:</p>
<pre><code>Server side rendering then client
takes over rendering:

┌─────────────────────────────────────┐
│   1) Client requests for web page   │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│   2) Server responds with server    │  User first
│ side rendered content along with a  │◀─   sees
│            &lt;script&gt; tag             │   content
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│     3) Client downloads script      │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│4) Client parses the returned script │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 5) Client executes returned script  │
└─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────┐
│ 6) Script starts rendering content  │
└─────────────────────────────────────┘
</code></pre>
<p>Server side rendering allows you to show <em>something</em> to your users more quickly,
especially so for users with slower machines and/or bandwidth.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="how-to-ssr"><a class="header" href="#how-to-ssr">How to SSR</a></h1>
<p>In the most simple case, server side rendering in <code>Percy</code> boils down to
rendering your virtual DOM to a <code>String</code> and responding to a client with
that <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust">use percy_dom::prelude::*;
use std::cell::Cell;

fn main () {
  let count_cell = Cell::new(5);

  let app = html! {
    &lt;div id=&quot;app&quot;&gt;
      &lt;button onclick=|_ev| { *count+= 1; }&gt;
        Hello world
      &lt;/button&gt;
    &lt;/div&gt;
  };


  let html_to_serve = app.to_string();
  // &lt;div id=&quot;app&quot;&gt;&lt;button&gt;Hello world&lt;/button&gt;&lt;/div&gt;

  // .. server string to client (http response) ...
}
</code></pre></pre>
<h2 id="hydrating-initial-state"><a class="header" href="#hydrating-initial-state">Hydrating initial state</a></h2>
<p>You'll usually want your views to be rendered based on some application state. So, typically, your server will</p>
<ol>
<li>Receive a request from the client</li>
<li>Set the initial application state based on the request</li>
<li>Render the application using the initial state</li>
<li>Reply with the initial HTML and the initial state</li>
<li>Client takes over rendering, starting from the initial state.</li>
</ol>
<p>To illustrate we'll take a look at an excerpt from a more realistic server side rendering example.</p>
<p>Afterwards you can check out the full example at <a href="https://github.com/chinedufn/percy/tree/master/examples/isomorphic">examples/isormorphic</a>.</p>
<hr />
<p>A more realistic server side rendering implementation would look like the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/app.css&quot;/&gt;
    &lt;link rel=&quot;shortcut icon&quot; href=&quot;#&quot; /&gt;
    &lt;title&gt;Rust Web App&lt;/title&gt;
&lt;/head&gt;
&lt;body style='margin: 0; padding: 0; width: 100%; height: 100%;'&gt;
  &lt;div id=&quot;isomorphic-rust-web-app&quot; style='width: 100%; height: 100%;'&gt;
      #HTML_INSERTED_HERE_BY_SERVER#
  &lt;/div&gt;
  &lt;script&gt;
    function downloadJson(path, callback) {
      fetch(path)
        .then(function(response) {
          return response.json();
        })
        .then(function(json) {
            callback(json);
        });
    }
  &lt;/script&gt;
  &lt;script type=module&gt;
    let client
    let updateScheduled = false

    window.GlobalJS = function () {}
    // TODO:
    // https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.request_animation_frame
    window.GlobalJS.prototype.update = function () {
      if (!updateScheduled) {
        requestAnimationFrame(() =&gt; {
          client.render()

          updateScheduled = false
        })
      }

      updateScheduled = true
    }
    window.global_js = new GlobalJS()

    import { Client, default as init } from '/static/isomorphic_client.js';

    async function run() {
      await init('/static/isomorphic_client_bg.wasm');

      client = new Client(window.initialState)
    }

    run();
  &lt;/script&gt;
  &lt;script&gt;
      window.initialState = '#INITIAL_STATE_JSON#'
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// examples/isormorphic/server/src/rocket_server.rs
// Check out the full application in /examples/isormorphic directory

{{#include ../../../../examples/isomorphic/server/src/rocket_server.rs}}
<span class="boring">}
</span></code></pre></pre>
<p>And then the client would use <code>serde</code> to deserialize the <code>initialState</code>
into a State struct and begin rendering using that State.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-url-params"><a class="header" href="#type-safe-url-params">Type Safe URL Params</a></h1>
<p><code>percy-router</code> provides functionality that helps you render different views when your users' visit different routes.</p>
<p>Let's take a look:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Imported from crates/percy-router-macro-test/src/book_example.rs

use percy_dom::prelude::*;
use percy_router::prelude::*;
use std::str::FromStr;

mod my_routes {
    use super::*;

    #[route(path = &quot;/users/:id/favorite-meal/:meal&quot;, on_visit = download_some_data)]
    pub(super) fn route_data_and_param(
        id: u16,
        state: Provided&lt;SomeState&gt;,
        meal: Meal,
    ) -&gt; VirtualNode {
        let id = format!(&quot;{}&quot;, id);
        let meal = format!(&quot;{:#?}&quot;, meal);

        html! {
            &lt;div&gt; User { id } loves { meal } &lt;/div&gt;
        }
    }
}

fn download_some_data(id: u16, state: Provided&lt;SomeState&gt;, meal: Meal) {
    // Check state to see if we've already downloaded data ...
    // If not - download the data that we need
}

#[test]
fn provided_data_and_param() {
    let mut router = Router::new(create_routes![my_routes::route_data_and_param]);
    router.provide(SomeState { happy: true });

    assert_eq!(
        &amp;router
            .view(&quot;/users/10/favorite-meal/breakfast&quot;)
            .unwrap()
            .to_string(),
        &quot;&lt;div&gt; User 10 loves Breakfast &lt;/div&gt;&quot;
    );
}

struct SomeState {
    happy: bool,
}

#[derive(Debug)]
enum Meal {
    Breakfast,
    Lunch,
    Dinner,
}

impl FromStr for Meal {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;breakfast&quot; =&gt; Meal::Breakfast,
            &quot;lunch&quot; =&gt; Meal::Lunch,
            &quot;dinner&quot; =&gt; Meal::Dinner,
            _ =&gt; Err(())?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-url-params-1"><a class="header" href="#type-safe-url-params-1">Type Safe URL Params</a></h1>
<p><code>percy-router</code> provides functionality that helps you render different views when your users' visit different routes.</p>
<p>Let's take a look:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Imported from crates/percy-router-macro-test/src/book_example.rs

use percy_dom::prelude::*;
use percy_router::prelude::*;
use std::str::FromStr;

mod my_routes {
    use super::*;

    #[route(path = &quot;/users/:id/favorite-meal/:meal&quot;, on_visit = download_some_data)]
    pub(super) fn route_data_and_param(
        id: u16,
        state: Provided&lt;SomeState&gt;,
        meal: Meal,
    ) -&gt; VirtualNode {
        let id = format!(&quot;{}&quot;, id);
        let meal = format!(&quot;{:#?}&quot;, meal);

        html! {
            &lt;div&gt; User { id } loves { meal } &lt;/div&gt;
        }
    }
}

fn download_some_data(id: u16, state: Provided&lt;SomeState&gt;, meal: Meal) {
    // Check state to see if we've already downloaded data ...
    // If not - download the data that we need
}

#[test]
fn provided_data_and_param() {
    let mut router = Router::new(create_routes![my_routes::route_data_and_param]);
    router.provide(SomeState { happy: true });

    assert_eq!(
        &amp;router
            .view(&quot;/users/10/favorite-meal/breakfast&quot;)
            .unwrap()
            .to_string(),
        &quot;&lt;div&gt; User 10 loves Breakfast &lt;/div&gt;&quot;
    );
}

struct SomeState {
    happy: bool,
}

#[derive(Debug)]
enum Meal {
    Breakfast,
    Lunch,
    Dinner,
}

impl FromStr for Meal {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;breakfast&quot; =&gt; Meal::Breakfast,
            &quot;lunch&quot; =&gt; Meal::Lunch,
            &quot;dinner&quot; =&gt; Meal::Dinner,
            _ =&gt; Err(())?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="on-visit-callback"><a class="header" href="#on-visit-callback">On Visit Callback</a></h1>
<p>You'll sometimes want to do something whenever you visit a route.</p>
<p>For example, you might want to download some data from an API whenever you
visit a route.</p>
<p>You can specify things like this using the <code>on_visit</code> attribute in the <code>#route(...)</code>
macro.</p>
<p>Doing this in the <code>#route(...)</code> macro makes it very clear what happens whenever
a route is visited.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snippet: examples/isomorphic/app/src/lib.rs

{{#bookimport ../../../../examples/isomorphic/app/src/lib.rs@on-visit-example}}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="css-in-rust"><a class="header" href="#css-in-rust">CSS in Rust</a></h1>
<p>... TODO ..</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>This section is meant to help you get up to speed with how you can contribute to the <code>Percy</code> project.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ol>
<li>
<p>Rust Nightly.</p>
<pre><code class="language-sh">rustup default nightly
rustup target add wasm32-unknown-unknown
</code></pre>
</li>
<li>
<p><a href="https://github.com/mozilla/geckodriver/releases">Install Geckodriver</a> since some of our tests are meant to run in a browser.
Put it somewhere in your path, i.e. you might move it to <code>/usr/local/bin/geckdriver</code>.</p>
</li>
<li>
<p>Download the project and make sure that you can run the test suite</p>
<pre><code class="language-sh">git clone https://github.com/chinedufn/percy
cd percy
./test.sh
</code></pre>
</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="types-of-contributions"><a class="header" href="#types-of-contributions">Types of Contributions</a></h1>
<p>There are three main types of contributions to <code>Percy</code>, all of which are equally important.</p>
<h3 id="documentation--book-contributions--examples"><a class="header" href="#documentation--book-contributions--examples">Documentation / Book Contributions / Examples</a></h3>
<p>Our documentation is the first thing that anyone interested in using <code>Percy</code> will see.
Before installing the tools, running the examples or starting up their own project they'll
peruse the documentation to get a sense of <code>Percy</code>'s design and how to get started.</p>
<p>Because of this, documentation and book contributions are incredibly useful and important.</p>
<p>While it's common for projects to dismiss typo fixes as unimportant contributions, we feel
the complete opposite. We strive for getting as close to &quot;perfect documentation&quot; as possible,
and anything that brings us a step closer matters.</p>
<h5 id="documentation"><a class="header" href="#documentation">Documentation</a></h5>
<p>Scroll around the codebase. If you don't instantly understand something then it is poorly
documented. Open up an issue or PR with your ideas on how it can be better communicated.</p>
<h5 id="book-contributions"><a class="header" href="#book-contributions">Book Contributions</a></h5>
<p>If there's a section that you think is missing from the book, PR the title of that section
with some placeholder text.</p>
<p>We're totally fine with not having book contributions fully fleshed out right away!</p>
<p>Having a placeholder makes it easy for yourself or someone else to feel motivated one day
and start hitting the keyboard.</p>
<pre><code class="language-sh"># To view the book locally as you edit
cd book &amp;&amp; mdbook serve --open
</code></pre>
<h5 id="examples"><a class="header" href="#examples">Examples</a></h5>
<p>If you can't figure out how exactly to implement something within 5 minutes that might mean
that you were underserved by the <code>examples</code> directory.</p>
<p>Open up an issue with your question or an idea with how to craft an example that would have
answered it!</p>
<h3 id="building-something-with-percy"><a class="header" href="#building-something-with-percy">Building Something with Percy</a></h3>
<p>When you're building a real application you run into problems, trade-offs and considerations
that you never could have thought of up front.</p>
<p>We want to uncover those problems and either address them in the main toolkit or point
people in the right direction for how to solve them in user land.</p>
<p>The more people that are using <code>Percy</code> to build things, the more of these problems we can
fix and/or suggest approaches for.</p>
<p>If you have an idea for something that you can build with <code>Percy</code> then get started. Feel
free to open up an issue with any questions or thoughts that you might have. Also open
issues / PRs as you run into problems / annoyances.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="design-of-percy"><a class="header" href="#design-of-percy">Design of <code>percy</code></a></h1>
<p>This section is intended to be a deep dive into how <code>percy</code>'s different internal pieces work today.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="diff--patch-algorithm"><a class="header" href="#diff--patch-algorithm">Diff / Patch Algorithm</a></h1>
<p>This section discusses the design of the diffing and patching algorithms as well as how
to troubleshoot and fix issues that might arise.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="diff--patch-walkthrough"><a class="header" href="#diff--patch-walkthrough">Diff / Patch Walkthrough</a></h1>
<p>From a user's perspective, rendering on the client side looks roughly like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a first virtual DOM in application memory then
// use this description to render into the real DOM
let old_vdom = html! { &lt;div&gt; Old &lt;/div&gt; };
pdom.update(old_vdom);

// Create a second virtual DOM in application memory then
// apply a minimal set of changes to the DOM to get it to look like
// this second virtual DOM representation
let new_vdom = html! { &lt;div&gt; New &lt;/div&gt; }
pdom.update(new_vdom);


// Create a thid virtual DOM in application memory then
// apply a minimal set of changes to the DOM to get it to look like
// this second virtual DOM representation
let new_vdom = html! { &lt;div&gt; &lt;span&gt;Very New&lt;/span&gt; &lt;/div&gt; }
pdom.update(new_vdom);
<span class="boring">}
</span></code></pre></pre>
<p>On the code side of things, the process is</p>
<ol>
<li>
<p>Compare the old virtual DOM with the new virtual DOM and generate a <code>Vec&lt;Patch&lt;'a&gt;&gt;</code></p>
</li>
<li>
<p>Iterate through <code>Vec&lt;Patch&lt;'a&gt;&gt;</code> and apply each of those patches in order to update the real DOM
that the user sees.</p>
</li>
</ol>
<h2 id="diffing"><a class="header" href="#diffing">Diffing</a></h2>
<p>Let's say that you have an old virtual dom that you want to update using a new virtual dom.</p>
<pre><code class="language-ignore">    Old vdom             New vdom

    ┌─────┐             ┌─────┐
    │ Div │             │ Div │
    └─────┘             └─────┘
       │                   │
  ┌────┴─────┐        ┌────┴─────┐
  ▼          ▼        ▼          ▼
┌────┐     ┌────┐   ┌────┐     ┌────┐
│Span│     │ Br │   │Img │     │ Br │
└────┘     └────┘   └────┘     └────┘
</code></pre>
<p>In our example the only thing that has changed is that the <code>Span</code> has become a <code>Img</code>.</p>
<p>So, we need to create a vector of patches that describes this.</p>
<p>Our diffing algorithm will recursively iterate through the virtual dom trees and generate a vector
of patches that looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Our patches would look something like this:
let patches = vec![
    // The real generated patch won't use the `html!` macro,
    // this is just for illustration.
    Patch::Replace(1, html! { &lt;span&gt; &lt;/span&gt; }),
];
<span class="boring">}
</span></code></pre></pre>
<p>This patch says to replace the node with index of 1, which is currently a <code>&lt;br&gt;</code> with a <code>&lt;span&gt;</code>.</p>
<p>How does the diffing algorithm determine the index?</p>
<p>As we encounter nodes in our old virtual dom we increment a node index, the root node being index 0.
Nodes are traversed breadth.</p>
<pre><code class="language-ignore">// Nodes are indexed breadth first.

            .─.
           ( 0 )
            `┬'
        ┌────┴──────┐
        │           │
        ▼           ▼
       .─.         .─.
      ( 1 )       ( 2 )
       `┬'         `─'
   ┌────┴───┐       │
   │        │       ├─────┬─────┐
   ▼        ▼       │     │     │
  .─.      .─.      ▼     ▼     ▼
 ( 3 )    ( 4 )    .─.   .─.   .─.
  `─'      `─'    ( 5 ) ( 6 ) ( 7 )
                   `─'   `─'   `─'
</code></pre>
<h2 id="patching"><a class="header" href="#patching">Patching</a></h2>
<p>There are several different types of patches that are described in our <code>Patch</code> enum.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use js_sys::Reflect;
use std::cell::RefCell;
use std::collections::HashSet;
use std::collections::{HashMap, VecDeque};
use std::rc::Rc;

use virtual_node::event::{insert_non_delegated_event, ElementEventsId, VirtualEventNode};
use virtual_node::VIRTUAL_NODE_MARKER_PROPERTY;
use wasm_bindgen::JsCast;
use wasm_bindgen::JsValue;
use web_sys::{Element, HtmlInputElement, HtmlTextAreaElement, Node, Text};

use crate::event::VirtualEvents;
use crate::patch::Patch;
use crate::{AttributeValue, PatchSpecialAttribute, VirtualNode};

/// Apply all of the patches to our old root node in order to create the new root node
/// that we desire. Also, update the `VirtualEvents` with the new virtual node's event callbacks.
///
/// This is usually used after diffing two virtual nodes.
// Tested in a browser in `percy-dom/tests`
pub fn patch&lt;N: Into&lt;Node&gt;&gt;(
   root_dom_node: N,
   new_vnode: &amp;VirtualNode,
   virtual_events: &amp;mut VirtualEvents,
   patches: &amp;[Patch],
) -&gt; Result&lt;(), JsValue&gt; {
   let root_events_node = virtual_events.root();

   let mut nodes_to_find = HashSet::new();

   for patch in patches {
       patch.insert_node_indices_to_find(&amp;mut nodes_to_find);
   }

   let mut node_queue = VecDeque::new();
   node_queue.push_back(NodeToProcess {
       node: root_dom_node.into(),
       events_node: root_events_node.clone(),
       events_node_parent: None,
       node_idx: 0,
   });

   let mut ctx = PatchContext {
       next_node_idx: 1,
       nodes_to_find,
       found_nodes: HashMap::new(),
       events_id_for_old_node_idx: HashMap::new(),
       node_queue,
   };

   while ctx.nodes_to_find.len() &gt;= 1 &amp;&amp; ctx.node_queue.len() &gt;= 1 {
       find_nodes(&amp;mut ctx);
   }

   for patch in patches {
       let patch_node_idx = patch.old_node_idx();

       if let Some((_node, elem_or_text, events_elem)) = ctx.found_nodes.get(&amp;patch_node_idx) {
           match elem_or_text {
               ElementOrText::Element(element) =&gt; {
                   apply_element_patch(&amp;element, events_elem, &amp;patch, virtual_events, &amp;ctx)?
               }
               ElementOrText::Text(text_node) =&gt; {
                   apply_text_patch(&amp;text_node, &amp;patch, virtual_events, &amp;events_elem.events_node)?;
               }
           };
       } else {
           // Right now this can happen if something outside of Percy goes into the DOM and
           //  deletes an element that is managed by Percy.
           panic!(
               &quot;We didn't find the element or text node that we were supposed to patch ({}).&quot;,
               patch_node_idx
           )
       }
   }

   overwrite_events(new_vnode, root_events_node, virtual_events);

   Ok(())
}

struct PatchContext {
   next_node_idx: u32,
   nodes_to_find: HashSet&lt;u32&gt;,
   found_nodes: HashMap&lt;u32, (Node, ElementOrText, EventsNodeAndParent)&gt;,
   events_id_for_old_node_idx: HashMap&lt;u32, ElementEventsId&gt;,
   node_queue: VecDeque&lt;NodeToProcess&gt;,
}
struct NodeToProcess {
   node: Node,
   events_node: Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;,
   events_node_parent: Option&lt;Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;&gt;,
   node_idx: u32,
}
enum ElementOrText {
   Element(Element),
   Text(Text),
}
struct EventsNodeAndParent {
   events_node: Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;,
   parent: Option&lt;Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;&gt;,
}

impl PatchContext {
   fn store_found_node(&amp;mut self, node_idx: u32, node: Node, events_node: EventsNodeAndParent) {
       self.nodes_to_find.remove(&amp;node_idx);
       match node.node_type() {
           Node::ELEMENT_NODE =&gt; {
               let elem = ElementOrText::Element(node.clone().unchecked_into());
               self.found_nodes.insert(node_idx, (node, elem, events_node));
           }
           Node::TEXT_NODE =&gt; {
               let text = ElementOrText::Text(node.clone().unchecked_into());
               self.found_nodes.insert(node_idx, (node, text, events_node));
           }
           other =&gt; unimplemented!(&quot;Unsupported root node type: {}&quot;, other),
       }
   }
}

fn find_nodes(ctx: &amp;mut PatchContext) {
   if ctx.nodes_to_find.len() == 0 {
       return;
   }

   let next = ctx.node_queue.pop_front();
   if next.is_none() {
       return;
   }

   let job = next.unwrap();
   let node = job.node;
   let events_node = job.events_node;
   let events_node_parent = job.events_node_parent;
   let cur_node_idx = job.node_idx;

   if let Some(events_elem) = events_node.borrow().as_element() {
       let events_id = events_elem.events_id();
       ctx.events_id_for_old_node_idx
           .insert(cur_node_idx, events_id);
   }

   if ctx.nodes_to_find.contains(&amp;cur_node_idx) {
       let events = EventsNodeAndParent {
           events_node: events_node.clone(),
           parent: events_node_parent,
       };
       ctx.store_found_node(cur_node_idx, node.clone(), events);
   }

   // We use child_nodes() instead of children() because children() ignores text nodes
   let children = node.child_nodes();
   let child_node_count = children.length();

   if child_node_count == 0 {
       return;
   }

   let events_node_borrow = events_node.borrow();
   let events_node_elem = &amp;events_node_borrow.as_element().unwrap();
   let mut next_child = events_node_elem.first_child();

   for i in 0..child_node_count {
       let child_node = children.item(i).unwrap();

       if !was_created_by_percy(&amp;child_node) {
           continue;
       }

       let next_node_idx = ctx.next_node_idx;

       match child_node.node_type() {
           Node::ELEMENT_NODE | Node::TEXT_NODE =&gt; {
               let events_child_node = next_child.unwrap();
               next_child = events_child_node.borrow().next_sibling().cloned();

               ctx.node_queue.push_back(NodeToProcess {
                   node: child_node,
                   events_node: events_child_node,
                   events_node_parent: Some(events_node.clone()),
                   node_idx: next_node_idx,
               });

               ctx.next_node_idx += 1;
           }
           Node::COMMENT_NODE =&gt; {
               // At this time we do not support user entered comment nodes, so if we see a comment
               // then it was a delimiter created by percy-dom in order to ensure that two
               // neighboring text nodes did not get merged into one by the browser. So we skip
               // over this percy-dom generated comment node.
           }
           _other =&gt; {
               // Ignoring unsupported child node type
               // TODO: What do we do with this situation?
           }
       };
   }
}

fn overwrite_events(
   node: &amp;VirtualNode,
   events_node: Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;,
   virtual_events: &amp;mut VirtualEvents,
) {
   if let Some(elem) = node.as_velement_ref() {
       let events_node = events_node.borrow();
       let events_node = events_node.as_element().unwrap();
       let events_id = events_node.events_id();

       for (event_name, event) in elem.events.iter() {
           virtual_events.overwrite_event_attrib_fn(&amp;events_id, event_name, event.clone());
       }

       let mut events_child = events_node.first_child();

       for child in elem.children.iter() {
           let e = events_child.unwrap();
           events_child = e.borrow().next_sibling().cloned();
           overwrite_events(child, e, virtual_events);
       }
   }
}

fn apply_element_patch(
   node: &amp;Element,
   events_elem_and_parent: &amp;EventsNodeAndParent,
   patch: &amp;Patch,
   virtual_events: &amp;mut VirtualEvents,
   ctx: &amp;PatchContext,
) -&gt; Result&lt;(), JsValue&gt; {
   match patch {
       Patch::AddAttributes(_node_idx, attributes) =&gt; {
           for (attrib_name, attrib_val) in attributes.iter() {
               match attrib_val {
                   AttributeValue::String(val_str) =&gt; {
                       node.set_attribute(attrib_name, val_str)?;

                       if attrib_name == &amp;&quot;value&quot; {
                           maybe_set_value_property(node, val_str)
                       }
                   }
                   AttributeValue::Bool(val_bool) =&gt; {
                       if *val_bool {
                           node.set_attribute(attrib_name, &quot;&quot;)?;
                       } else {
                           node.remove_attribute(attrib_name)?;
                       }
                   }
               }
           }

           Ok(())
       }
       Patch::RemoveAttributes(_node_idx, attributes) =&gt; {
           for attrib_name in attributes.iter() {
               node.remove_attribute(attrib_name)?;
           }

           Ok(())
       }
       Patch::Replace {
           old_idx: _,
           new_node,
       } =&gt; {
           let (created_node, events) = new_node.create_dom_node(virtual_events);

           node.replace_with_with_node_1(&amp;created_node)?;

           let mut events_elem = events_elem_and_parent.events_node.borrow_mut();
           events_elem.replace_with_node(events);

           Ok(())
       }
       Patch::InsertBefore {
           anchor_old_node_idx: _,
           new_nodes,
       } =&gt; {
           let parent = node.parent_node().unwrap();
           let parent: Element = parent.dyn_into().unwrap();

           let events_parent = events_elem_and_parent.parent.as_ref().unwrap();

           for new_node in new_nodes {
               let (created_node, events) = new_node.create_dom_node(virtual_events);

               parent.insert_before(&amp;created_node, Some(&amp;node))?;
               events_parent.borrow_mut().insert_before(
                   Rc::new(RefCell::new(events)),
                   events_elem_and_parent.events_node.clone(),
               );
           }

           Ok(())
       }
       Patch::MoveNodesBefore {
           anchor_old_node_idx: _,
           to_move,
       } =&gt; {
           let parent = node.parent_node().unwrap();
           let parent: Element = parent.dyn_into().unwrap();

           let events_parent = events_elem_and_parent.parent.as_ref().unwrap();
           let mut events_parent = events_parent.borrow_mut();

           for to_move_node in to_move {
               let (to_move_dom_node, _, to_move_node_events) =
                   ctx.found_nodes.get(to_move_node).unwrap();

               parent.insert_before(to_move_dom_node, Some(&amp;node))?;

               events_parent.remove_node_from_siblings(&amp;to_move_node_events.events_node);
               events_parent.insert_before(
                   to_move_node_events.events_node.clone(),
                   events_elem_and_parent.events_node.clone(),
               );
           }

           Ok(())
       }
       Patch::RemoveChildren {
           parent_old_node_idx: _,
           to_remove,
       } =&gt; {
           let parent = node;

           let events_elem = events_elem_and_parent.events_node.borrow_mut();
           let mut events_parent = events_elem;

           for idx in to_remove {
               let (node_to_remove, _, events_node_to_remove) = ctx.found_nodes.get(idx).unwrap();
               parent.remove_child(&amp;node_to_remove)?;

               events_parent.remove_node_from_siblings(&amp;events_node_to_remove.events_node);
           }

           Ok(())
       }
       Patch::AppendChildren {
           parent_old_node_idx: _,
           new_nodes,
       } =&gt; {
           let parent = &amp;node;

           let events_elem = events_elem_and_parent.events_node.borrow_mut();
           let mut events_parent = events_elem;

           for new_node in new_nodes {
               let (created_node, events) = new_node.create_dom_node(virtual_events);

               parent.append_child(&amp;created_node)?;

               events_parent
                   .as_element_mut()
                   .unwrap()
                   .append_child(Rc::new(RefCell::new(events)));
           }

           Ok(())
       }
       Patch::MoveToEndOfSiblings {
           parent_old_node_idx: _,
           siblings_to_move,
       } =&gt; {
           let parent = node;

           let events_elem = events_elem_and_parent.events_node.borrow_mut();
           let mut events_parent = events_elem;

           for node in siblings_to_move {
               let (dom_node_to_move, _, events_node_to_move) = ctx.found_nodes.get(node).unwrap();

               parent.append_child(&amp;dom_node_to_move)?;

               events_parent.remove_node_from_siblings(&amp;events_node_to_move.events_node);
               events_parent
                   .as_element_mut()
                   .unwrap()
                   .append_child(events_node_to_move.events_node.clone());
           }

           Ok(())
       }
       Patch::ChangeText(_node_idx, _new_node) =&gt; {
           unreachable!(&quot;Elements should not receive ChangeText patches.&quot;)
       }
       Patch::ValueAttributeUnchanged(_node_idx, value) =&gt; {
           node.set_attribute(&quot;value&quot;, value.as_string().unwrap())?;
           maybe_set_value_property(node, value.as_string().unwrap());

           Ok(())
       }
       Patch::SpecialAttribute(special) =&gt; match special {
           PatchSpecialAttribute::CallOnCreateElemOnExistingNode(_node_idx, new_node) =&gt; {
               new_node
                   .as_velement_ref()
                   .unwrap()
                   .special_attributes
                   .maybe_call_on_create_element(&amp;node);

               Ok(())
           }
           PatchSpecialAttribute::CallOnRemoveElem(_, old_node) =&gt; {
               old_node
                   .as_velement_ref()
                   .unwrap()
                   .special_attributes
                   .maybe_call_on_remove_element(node);

               Ok(())
           }
           PatchSpecialAttribute::SetDangerousInnerHtml(_node_idx, new_node) =&gt; {
               let new_inner_html = new_node
                   .as_velement_ref()
                   .unwrap()
                   .special_attributes
                   .dangerous_inner_html
                   .as_ref()
                   .unwrap();

               node.set_inner_html(new_inner_html);

               Ok(())
           }
           PatchSpecialAttribute::RemoveDangerousInnerHtml(_node_idx) =&gt; {
               node.set_inner_html(&quot;&quot;);

               Ok(())
           }
       },
       Patch::AddEvents(node_idx, new_events) =&gt; {
           let events_id = ctx.events_id_for_old_node_idx.get(node_idx).unwrap();

           for (event_name, event) in new_events {
               if event_name.is_delegated() {
                   virtual_events.insert_event(
                       *events_id,
                       (*event_name).clone(),
                       (*event).clone(),
                       None,
                   );
               } else {
                   insert_non_delegated_event(node, event_name, event, *events_id, virtual_events);
               }
           }

           Ok(())
       }
       Patch::RemoveEvents(node_idx, events) =&gt; {
           let events_id = ctx.events_id_for_old_node_idx.get(node_idx).unwrap();

           for (event_name, _event) in events {
               if !event_name.is_delegated() {
                   let wrapper =
                       virtual_events.remove_non_delegated_event_wrapper(events_id, event_name);
                   node.remove_event_listener_with_callback(
                       event_name.without_on_prefix(),
                       wrapper.as_ref().as_ref().unchecked_ref(),
                   )
                   .unwrap();
               }

               virtual_events.remove_event_handler(events_id, event_name);
           }

           Ok(())
       }
       Patch::RemoveAllVirtualEventsWithNodeIdx(node_idx) =&gt; {
           let events_id = ctx.events_id_for_old_node_idx.get(node_idx).unwrap();
           virtual_events.remove_node(events_id);
           Ok(())
       }
   }
}

fn apply_text_patch(
   node: &amp;Text,
   patch: &amp;Patch,
   events: &amp;mut VirtualEvents,
   events_elem: &amp;Rc&lt;RefCell&lt;VirtualEventNode&gt;&gt;,
) -&gt; Result&lt;(), JsValue&gt; {
   match patch {
       Patch::ChangeText(_node_idx, new_node) =&gt; {
           node.set_node_value(Some(&amp;new_node.text));
       }
       Patch::Replace {
           old_idx: _,
           new_node,
       } =&gt; {
           let (elem, enode) = new_node.create_dom_node(events);
           node.replace_with_with_node_1(&amp;elem)?;

           events_elem.borrow_mut().replace_with_node(enode);
       }
       other =&gt; {
           unreachable!(
               &quot;Text nodes should only receive ChangeText or Replace patches, not {:?}.&quot;,
               other,
           )
       }
   };

   Ok(())
}

// See crates/percy-dom/tests/value_attribute.rs
fn maybe_set_value_property(node: &amp;Element, value: &amp;str) {
   if let Some(input_node) = node.dyn_ref::&lt;HtmlInputElement&gt;() {
       input_node.set_value(value);
   } else if let Some(textarea_node) = node.dyn_ref::&lt;HtmlTextAreaElement&gt;() {
       textarea_node.set_value(value)
   }
}

// Looks for a property on the element. If it's there then this is a Percy element.
//
// TODO: We need to know not just if the node was created by Percy... but if it was created by
//  this percy-dom instance.. So give every PercyDom instance a random number and store that at the
//  virtual node marker property value.
fn was_created_by_percy(node: &amp;Node) -&gt; bool {
   let marker = Reflect::get(&amp;node, &amp;VIRTUAL_NODE_MARKER_PROPERTY.into()).unwrap();

   match marker.as_f64() {
       Some(_marker) =&gt; true,
       None =&gt; false,
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>When patching we iterate over our vector of patches, look at the node index for the patch, then
traverse the real DOM in order to find the corresponding DOM element.</p>
<p>So if a patch applies to the node with index 4, we'll start at our root node (node 0) and crawl it's children
and it's children's children until we've gone through node 1, 2 and 3.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fixing-diffpatch-issues"><a class="header" href="#fixing-diffpatch-issues">Fixing diff/patch issues</a></h1>
<p>As our virtual dom implementation ages it will become more and more resilient, but while we're still
an experimental library it's possible that the diff/patch algorithm could fail in some scenarios.</p>
<p>If you notice a failure the first step is to open a new issue.</p>
<p>Ideally you include an example start node and end node that isn't working properly.</p>
<p>Let's make up an example here.</p>
<pre><code># Example things that you'd include in your issue.

start: html! { &lt;div&gt; &lt;/div&gt;  }

end: html! { &lt;span&gt; &lt;/span&gt; }

Observed error: It somehow ends up as &lt;b&gt;&lt;/b&gt; in my browser!
</code></pre>
<hr />
<p>If you've opened this issue you've already made a big contribution!</p>
<p>If you'd like to go further, here's how to get to the root of the problem.</p>
<h2 id="debugging-failed-diff"><a class="header" href="#debugging-failed-diff">Debugging Failed Diff</a></h2>
<p>The easiest place to start is by adding a new diff test and seeing what patches you get.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use crate::diff::diff;
use crate::patch::Patch;
use virtual_node::VirtualNode;

/// Test that we generate the right Vec&lt;Patch&gt; for some start and end virtual dom.
pub struct DiffTestCase&lt;'a&gt; {
    // ex: html! { &lt;div&gt; &lt;/div&gt; }
    pub old: VirtualNode,
    // ex: html! { &lt;strong&gt; &lt;/strong&gt; }
    pub new: VirtualNode,
    // ex: vec![Patch::Replace(0, &amp;html! { &lt;strong&gt;&lt;/strong&gt; })],
    pub expected: Vec&lt;Patch&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; DiffTestCase&lt;'a&gt; {
    pub fn test(&amp;self) {
        // ex: vec![Patch::Replace(0, &amp;html! { &lt;strong&gt;&lt;/strong&gt; })],
        let patches = diff(&amp;self.old, &amp;self.new);

        assert_eq!(patches, self.expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Diff patch tests get added in <code>diff.rs</code>. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// diff.rs

#[test]
fn add_children() {
   DiffTestCase {
       old: html! { &lt;div&gt; &lt;b&gt;&lt;/b&gt; &lt;/div&gt; },
       new: html! { &lt;div&gt; &lt;b&gt;&lt;/b&gt; &lt;new&gt;&lt;/new&gt; &lt;/div&gt; },
       expected: vec![Patch::AppendChildren(0, vec![&amp;html! { &lt;new&gt;&lt;/new&gt; }])],
       description: &quot;Added a new node to the root node&quot;,
   }.test();
}
<span class="boring">}
</span></code></pre></pre>
<p>To run your new test case:</p>
<pre><code class="language-sh"># To run just your new diff test
cargo test -p percy-dom --lib my_new_test_name_here

# To run all diff tests
cargo test -p percy-dom --lib diff::tests
</code></pre>
<p>If things are failing then you've found the issue!</p>
<p>Please comment back on your original issue with your findings.</p>
<p>If everything is passing, then it must be a patching issue.</p>
<h2 id="debugging-failed-patch"><a class="header" href="#debugging-failed-patch">Debugging Failed Patch</a></h2>
<p>If the diff checked out, then the issue must be in the patching process.</p>
<p>Patches are tested in <code>crates/percy-dom/tests/diff_patch.rs</code></p>
<p>A patch test case looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Kept in its own file to more easily import into the book

use console_error_panic_hook;
use percy_dom::event::VirtualEvents;
use percy_dom::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{Element, Node};

/// A test case that both diffing and patching are working in a real browser
pub struct DiffPatchTest&lt;'a&gt; {
    /// Description of the test case.
    /// TODO: Delete the description.. not that useful and easy to forget to update after
    ///  copy/pasting another similar test.
    pub desc: &amp;'static str,
    /// The old virtual node.
    pub old: VirtualNode,
    /// The new virtual node.
    pub new: VirtualNode,
    /// By default we generate the expected based on `new.to_string()`. You can
    /// use this field to override the expected HTML after patching.
    pub override_expected: Option&lt;&amp;'a str&gt;,
}

impl&lt;'a&gt; DiffPatchTest&lt;'a&gt; {
    pub fn test(&amp;mut self) {
        console_error_panic_hook::set_once();

        let mut events = VirtualEvents::new();

        // Create a DOM node of the virtual root node
        let (root_node, enode) = self.old.create_dom_node(&amp;mut events);
        events.set_root(enode);

        // Clone since percy_dom::patch takes ownership of the root node.
        let patched_root_node: Node = root_node.clone();

        // Generate patches
        let patches = percy_dom::diff(&amp;self.old, &amp;self.new);

        // Patch our root node. It should now look like `self.new`
        percy_dom::patch(root_node, &amp;self.new, &amp;mut events, &amp;patches).unwrap();

        // Determine the expected outer HTML
        let expected_outer_html = match self.override_expected {
            Some(ref expected) =&gt; expected.to_string(),
            None =&gt; self.new.to_string(),
        };

        let actual_outer_html = match patched_root_node.node_type() {
            Node::ELEMENT_NODE =&gt; patched_root_node.unchecked_into::&lt;Element&gt;().outer_html(),
            Node::TEXT_NODE =&gt; patched_root_node.text_content().unwrap_or(&quot;&quot;.into()),
            _ =&gt; panic!(&quot;Unhandled node type&quot;),
        };

        assert_eq!(&amp;actual_outer_html, &amp;expected_outer_html, &quot;{}&quot;, self.desc);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example diff patch test case.
// Found in `crates/percy-dom/tests/diff_patch.rs`

use percy_dom::prelude::*;

wasm_bindgen_test_configure!(run_in_browser);

mod diff_patch_test_case;
use self::diff_patch_test_case::DiffPatchTest;

#[wasm_bindgen_test]
fn truncate_children() {
    DiffPatchTest {
        desc: &quot;Truncates extra children&quot;,
        old: html! {
         &lt;div&gt;
           &lt;div&gt; &lt;div&gt; &lt;b&gt;&lt;/b&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;/div&gt;
<span class="boring">}
</span></code></pre></pre>
<pre><code># Run just your new diff patch test
wasm-pack test --chrome --headless crates/percy-dom --test diff_patch -- my_test_name_here

# Run all diff patch tests that contain the word replace
wasm-pack test --chrome --headless crates/percy-dom --test diff_patch -- replace

# Run all diff patch tests
wasm-pack test --chrome --headless crates/percy-dom --test diff_patch
</code></pre>
<p>Create your new test case and run it to see if things fail.</p>
<p>If they do, update your original issue with your findings.</p>
<h2 id="fixing-the-problem"><a class="header" href="#fixing-the-problem">Fixing the problem</a></h2>
<p>Look at the documentation for the diff algorithm and the patch algorithm to get a good sense of where and how our
diffing and patching is implemented. Fixing the problem will require you to dive into that code.</p>
<p>As you go, if you see opportunities to make the code more understandable, DRY or better commented, seize them!</p>
<p>Look through your errors and try to pinpoint the exact place that the bug is stemming from. If you're stuck, continue
to update your issue with your questions and progress and someone will get back to you.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sibling-text-nodes"><a class="header" href="#sibling-text-nodes">Sibling text nodes</a></h1>
<p>If you render two text nodes next to them the browser will see them as just
one text node.</p>
<p>For example, when you have a component that looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use percy_dom::prelude::*;

let world = &quot;world&quot;;

let sibling_text_nodes = html! { &lt;div&gt; hello {world} &lt;/div&gt; };
<span class="boring">}
</span></code></pre></pre>
<p>A browser will end up with something like this:</p>
<pre><code class="language-html"> &lt;div&gt;Hello World&lt;/div&gt;
</code></pre>
<p>The <code>textContent</code> of the div in the browser is now &quot;Hello World&quot;.</p>
<p>If we did not work around this behavior we wouldn't be able  to patch the DOM when two text nodes are next to each other.
We'd have no way of knowing how to find the original, individual strings that we wanted to render.</p>
<p>To get around this here's what we actually end up rendering:</p>
<pre><code class="language-html">&lt;div&gt;Hello &lt;!--ptns--&gt;World&lt;/div&gt;
</code></pre>
<p>Note the new <code>&lt;!--ptns--&gt;</code> comment node. Here's what <code>percy_dom</code>'s <code>createElement()</code> method ended up doing:</p>
<ol>
<li>Saw the &quot;Hello&quot; virtual text and appended a real Text node into the real DOM <code>&lt;div&gt;</code></li>
<li>Saw the &quot;World&quot; virtual text and saw that the previous element was also a virtual text node</li>
<li>Appended a <code>&lt;!--ptns&gt;</code> real comment element into the <code>&lt;div&gt;</code></li>
<li>Appended a real &quot;World&quot; Text node into the <code>&lt;div&gt;</code></li>
</ol>
<p>If we later wanted to patch the DOM with a new component</p>
<pre><code>let different_text = &quot;there&quot;;
let sibling_text_nodes = html! { &lt;div&gt; hello {different_text} } &lt;/div&gt; };
</code></pre>
<p>Our <code>percy_dom</code> patch function would be able to find the old &quot;World&quot; text node since we've ensured that it
did not get merged in with any other text nodes.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<p>There are two categories of events, delegated and per-node events.</p>
<h2 id="delegated-events"><a class="header" href="#delegated-events">Delegated Events</a></h2>
<p>For delegated events, we attach a single event listener to the application's mount point.</p>
<p>So, say we have a delegated event <code>onclick</code>. If you create 50 DOM nodes with <code>onclick</code> handlers,
only one <code>onclick</code> handler will be in the DOM.</p>
<p>This event listener handles all events and handles bubbling and <code>.stop_propagation()</code>.</p>
<h2 id="per-node-events"><a class="header" href="#per-node-events">Per-node Events</a></h2>
<p>For per-node events we attach the event to the DOM node.</p>
<p>So, say <code>onfoo</code> is a per-node event. If you create 50 DOM nodes with 50 <code>onfoo</code> handlers,
there will be 50 <code>onfoo</code> callbacks in the DOM (one per node).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="router"><a class="header" href="#router">Router</a></h1>
<p>Percy provides a route that can be used for deciding which views to render
based on, say, the route that the user has visited in their browser.</p>
<p>Here's an example</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Imported from crates/percy-router-macro-test/src/book_example.rs

use percy_dom::prelude::*;
use percy_router::prelude::*;
use std::str::FromStr;

mod my_routes {
    use super::*;

    #[route(path = &quot;/users/:id/favorite-meal/:meal&quot;, on_visit = download_some_data)]
    pub(super) fn route_data_and_param(
        id: u16,
        state: Provided&lt;SomeState&gt;,
        meal: Meal,
    ) -&gt; VirtualNode {
        let id = format!(&quot;{}&quot;, id);
        let meal = format!(&quot;{:#?}&quot;, meal);

        html! {
            &lt;div&gt; User { id } loves { meal } &lt;/div&gt;
        }
    }
}

fn download_some_data(id: u16, state: Provided&lt;SomeState&gt;, meal: Meal) {
    // Check state to see if we've already downloaded data ...
    // If not - download the data that we need
}

#[test]
fn provided_data_and_param() {
    let mut router = Router::new(create_routes![my_routes::route_data_and_param]);
    router.provide(SomeState { happy: true });

    assert_eq!(
        &amp;router
            .view(&quot;/users/10/favorite-meal/breakfast&quot;)
            .unwrap()
            .to_string(),
        &quot;&lt;div&gt; User 10 loves Breakfast &lt;/div&gt;&quot;
    );
}

struct SomeState {
    happy: bool,
}

#[derive(Debug)]
enum Meal {
    Breakfast,
    Lunch,
    Dinner,
}

impl FromStr for Meal {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;breakfast&quot; =&gt; Meal::Breakfast,
            &quot;lunch&quot; =&gt; Meal::Lunch,
            &quot;dinner&quot; =&gt; Meal::Dinner,
            _ =&gt; Err(())?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This section will dive into how that works.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="route-macro"><a class="header" href="#route-macro">route macro</a></h1>
<p>The <code>#[route(...)]</code> attribute macro is used to annotate functions that we cant to get called
when we visit a certain route.</p>
<p>Before diving into how it works, let's take a look at what code the macro generates for you.</p>
<p>Seeing the end result will make it easier to understand what we're doing and why we do it.</p>
<h2 id="generated-code"><a class="header" href="#generated-code">Generated Code</a></h2>
<p>Let's say that you have a file that looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Imported from crates/percy-router-macro-test/src/book_example.rs

use percy_dom::prelude::*;
use percy_router::prelude::*;
use std::str::FromStr;

mod my_routes {
    use super::*;

    #[route(path = &quot;/users/:id/favorite-meal/:meal&quot;, on_visit = download_some_data)]
    pub(super) fn route_data_and_param(
        id: u16,
        state: Provided&lt;SomeState&gt;,
        meal: Meal,
    ) -&gt; VirtualNode {
        let id = format!(&quot;{}&quot;, id);
        let meal = format!(&quot;{:#?}&quot;, meal);

        html! {
            &lt;div&gt; User { id } loves { meal } &lt;/div&gt;
        }
    }
}

fn download_some_data(id: u16, state: Provided&lt;SomeState&gt;, meal: Meal) {
    // Check state to see if we've already downloaded data ...
    // If not - download the data that we need
}

#[test]
fn provided_data_and_param() {
    let mut router = Router::new(create_routes![my_routes::route_data_and_param]);
    router.provide(SomeState { happy: true });

    assert_eq!(
        &amp;router
            .view(&quot;/users/10/favorite-meal/breakfast&quot;)
            .unwrap()
            .to_string(),
        &quot;&lt;div&gt; User 10 loves Breakfast &lt;/div&gt;&quot;
    );
}

struct SomeState {
    happy: bool,
}

#[derive(Debug)]
enum Meal {
    Breakfast,
    Lunch,
    Dinner,
}

impl FromStr for Meal {
    type Err = ();

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(match s {
            &quot;breakfast&quot; =&gt; Meal::Breakfast,
            &quot;lunch&quot; =&gt; Meal::Lunch,
            &quot;dinner&quot; =&gt; Meal::Dinner,
            _ =&gt; Err(())?,
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>#[route(...)]</code> macro above will automatically generate the following code (some unimportant bits have been removed for brevity):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO:: This code example isn't imported from a real file so it might go stale over time.

fn route_data_and_param(id: u16, state: Provided&lt;SomeState&gt;, meal: Meal) -&gt; VirtualNode {
  // ... removed ...
}
fn create_route_data_and_param() -&gt; Route {
    fn route_param_parser(param_key: &amp;str, param_val: &amp;str) -&gt; Option&lt;Box&lt;dyn RouteParam&gt;&gt; {
        match param_key {
            &quot;id&quot; =&gt; {
                return Some(Box::new(
                    u16::from_str_param(param_val).expect(&quot;Macro parsed param&quot;),
                ));
            }
            &quot;meal&quot; =&gt; {
                return Some(Box::new(
                    Meal::from_str_param(param_val).expect(&quot;Macro parsed param&quot;),
                ));
            }
            _ =&gt; panic!(&quot;TODO: Handle this case...&quot;),
        };
        None
    }
    Route::new(
        &quot;/users/:id/favorite-meal/:meal&quot;,
        Box::new(route_param_parser),
    )
}
pub mod __route_data_and_param_mod__ {
    #![deny(warnings)]
    #![allow(non_camel_case_types)]
    use super::*;
    pub struct route_data_and_param_handler {
        route: Route,
        provided: Option&lt;ProvidedMap&gt;,
    }
    impl route_data_and_param_handler {
        pub fn new() -&gt; route_data_and_param_handler {
            route_data_and_param_handler {
                route: create_route_data_and_param(),
                provided: None,
            }
        }
    }
    impl RouteHandler for route_data_and_param_handler {
        fn route(&amp;self) -&gt; &amp;Route {
            &amp;self.route
        }
        fn set_provided(&amp;mut self, provided: ProvidedMap) {
            self.provided = Some(provided);
        }
        fn provided(&amp;self) -&gt; &amp;ProvidedMap {
            &amp;self.provided.as_ref().unwrap()
        }
        fn view(&amp;self, incoming_route: &amp;str) -&gt; VirtualNode {
            let id = self
                .route()
                .find_route_param(incoming_route, &quot;id&quot;)
                .expect(&quot;Finding route param&quot;);
            let meal = self
                .route()
                .find_route_param(incoming_route, &quot;meal&quot;)
                .expect(&quot;Finding route param&quot;);
            let state = self.provided().borrow();
            let state = state
                .get(&amp;std::any::TypeId::of::&lt;Provided&lt;SomeState&gt;&gt;())
                .unwrap()
                .downcast_ref::&lt;Provided&lt;SomeState&gt;&gt;()
                .expect(&quot;Downcast param&quot;);
            route_data_and_param(
                u16::from_str_param(id).expect(
                    // ... removed ...
                )),
                Provided::clone(state),
                Meal::from_str_param(meal).expect(
                  // ... removed ...
                ),
            )
        }
    }
}
fn provided_data_and_param() {
    let mut router = Router::default();
    router.provide(SomeState { happy: true });
    router.set_route_handlers(&lt;[_]&gt;::into_vec(box [Box::new(
        self::__route_data_and_param_mod__::route_data_and_param_handler::new(),
    )]));
    // ... removed ...
}
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="html-macro-1"><a class="header" href="#html-macro-1">html macro</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-errors"><a class="header" href="#compile-time-errors">Compile Time Errors</a></h1>
<p>The <code>html-macro</code> provides compile time errors to help catch mistakes.</p>
<p>Every compile time error is tested in <code>crates/html-macro-ui</code> using the <a href="https://github.com/dtolnay/trybuild">trybuild</a>
crate.</p>
<p>If you have an idea for an error that you don't see here <a href="https://github.com/chinedufn/percy/issues/new">open an issue!</a></p>
<p>Here are a few examples:</p>
<h4 id="wrong-closing-tag"><a class="header" href="#wrong-closing-tag">Wrong closing tag</a></h4>
<p>You've opened with one tag but are attempting to close with another.</p>
<pre><pre class="playground"><code class="language-rust">extern crate percy_dom;
use percy_dom::prelude::*;

// Expected a closing div tag, found a closing strong tag
fn main() {
    html! {
        &lt;div&gt; &lt;/strong&gt;
    };
}
</code></pre></pre>
<pre><code>error: Wrong closing tag. Try changing &quot;strong&quot; into &quot;div&quot;
 --&gt; $DIR/wrong_closing_tag.rs:7:17
  |
7 |         &lt;div&gt; &lt;/strong&gt;
  |                 ^^^^^^
</code></pre>
<h4 id="should-be-self-closing-tag"><a class="header" href="#should-be-self-closing-tag">Should be self closing tag</a></h4>
<p>The tag that you are trying to use is a self closing tagl</p>
<pre><pre class="playground"><code class="language-rust">extern crate percy_dom;
use percy_dom::prelude::*;

// We are using open and close tags for a tag that should
// actually be a self closing tag
fn main() {
    html! {
        &lt;br&gt;&lt;/br&gt;
    };
}
</code></pre></pre>
<pre><code>error: br is a self closing tag. Try &quot;&lt;br&gt;&quot; or &quot;&lt;br /&gt;&quot;
 --&gt; $DIR/should_be_self_closing_tag.rs:8:15
  |
8 |         &lt;br&gt;&lt;/br&gt;
  |               ^^
</code></pre>
<h4 id="invalid-html-tag"><a class="header" href="#invalid-html-tag">Invalid HTML tag</a></h4>
<p>You're trying to use a tag that isn't in the HTML specification.
This might happen if you've made a typo.</p>
<pre><pre class="playground"><code class="language-rust">//! # To Run
//!
//! cargo test -p html-macro-test --lib ui -- trybuild=invalid_html_tag.rs

extern crate percy_dom;
use percy_dom::prelude::*;

// Used a tag name that does not exist in the HTML spec
fn main() {
    html! {
        &lt;invalidtagname&gt;&lt;/invalidtagname&gt;
    };
}
</code></pre></pre>
<pre><code>error: invalidtagname is not a valid HTML tag.

       If you are trying to use a valid HTML tag, perhaps there's a typo?

       If you are trying to use a custom component, please capitalize the component name.

       custom components: https://chinedufn.github.io/percy/html-macro/custom-components/index.html
  --&gt; src/tests/ui/invalid_html_tag.rs
   |
   |         &lt;invalidtagname&gt;&lt;/invalidtagname&gt;
   |          ^^^^^^^^^^^^^^
</code></pre>
<h4 id="on-create-element-without-key"><a class="header" href="#on-create-element-without-key">on create element without key</a></h4>
<p>You set the <code>on_create_element</code> but did not set a key.</p>
<pre><pre class="playground"><code class="language-rust">//! # To Run
//!
//! cargo test -p html-macro-test --lib ui -- trybuild=on_create_element_without_key.rs

extern crate percy_dom;
use percy_dom::prelude::*;

// Used the `on_create_element` attribute without providing a key attribute.
fn main() {
    html! {
        &lt;div on_create_element = ||{} &gt;
        &lt;/div&gt;
    };
}
</code></pre></pre>
<pre><code>error: Whenever you use the `on_create_element=...` attribute,
       you must also use must use the `key=&quot;...&quot;` attribute.

       Documentation:
         -&gt; https://chinedufn.github.io/percy/html-macro/real-elements-and-nodes/on-create-elem/index.html

  --&gt; src/tests/ui/on_create_element_without_key.rs
   |
   |         &lt;div on_create_element = ||{} &gt;
   |              ^^^^^^^^^^^^^^^^^
</code></pre>
<h4 id="on-remove-element-without-key"><a class="header" href="#on-remove-element-without-key">on remove element without key</a></h4>
<p>You set the <code>on_remove_element</code> but did not set a key.</p>
<pre><pre class="playground"><code class="language-rust">//! # To Run
//!
//! cargo test -p html-macro-test --lib ui -- trybuild=on_remove_element_without_key.rs

extern crate percy_dom;
use percy_dom::prelude::*;

// Used the `on_remove_element` attribute without providing a key attribute.
fn main() {
    html! {
        &lt;div on_remove_element = ||{} &gt;
        &lt;/div&gt;
    };
}
</code></pre></pre>
<pre><code>error: Whenever you use the `on_remove_element=...` attribute,
       you must also use must use the `key=&quot;...&quot;` attribute.

       Documentation:
         -&gt; https://chinedufn.github.io/percy/html-macro/real-elements-and-nodes/on-remove-elem/index.html

  --&gt; src/tests/ui/on_remove_element_without_key.rs
   |
   |         &lt;div on_remove_element = ||{} &gt;
   |              ^^^^^^^^^^^^^^^^^
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
